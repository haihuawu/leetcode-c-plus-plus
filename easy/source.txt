C++
//
//  main.cpp
//  LC28
//
//  Created by H.HUA WU on 11/20/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

// Implement strStr()

int strStr(string haystack, string needle) {
    int result = -1;
    // needle size less than or equal to 0, return 0. same for haystack
    if (needle.size()<=0 && haystack.size()<=0){
        return 0;
    }
    // needle size larger than haystack, return -1
    if (needle.size()>haystack.size() ){
        return -1;
    }
    // needle size is less than or equal to 0, return 0
    if (needle.size()<=0){
        return 0;
    }
    
    // find same part between needle and haystack
    for (int i=0;i<haystack.size()-needle.size()+1;i++){
        int j = 0;
        int tempi = i;
        for (j=0;j<needle.size();j++){
            if (needle[j] != haystack[tempi]){
                break;
            }
            else{
                tempi++;
            }
        }
        if (j==needle.size()){
            result = i;
            break;
        }
        
    }
    return result;
}


//
//  main.cpp
//  LC35
//
//  Created by H.HUA WU on 11/23/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

// Search Insert Position

int searchInsert(vector<int>& nums, int target) {
    int result = 0;
    while (result < nums.size()){
	// target equal or less than current nums element, return index
        if(target == nums[result]){
            return result;
        }
        else if(target < nums[result]){
            return result;
        }
        else{
            result++;
        }        
    }
    return result;
}


//
//  main.cpp
//  LC38
//
//  Created by H.HUA WU on 11/28/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//


string countAndSay(int n) {
    if(n==1)
    {
        return "1";
    }
    string s = "";
    string str = countAndSay(n-1)+"*";
    int count = 1;
    for(int i=0;i<str.length()-1;i++)
    {
        if(str[i] == str[i+1])
        {
            count++;
        }
        else
        {
            s = s+ to_string(count)+str[i];
            count = 1;
            
        }
    }
    
    return s;
}


//
//  main.cpp
//  LC53
//
//  Created by H.HUA WU on 11/28/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//


int maxSubArray(vector<int>& nums) {
    int size = (int) nums.size();
    int max = nums[0];
    int dp[size];
    dp[0] = nums[0];
    for(int i=1;i<size;i++)
    {
        dp[i] = nums[i] + (dp[i-1]>0? dp[i-1]:0);
        max = max>dp[i]? max:dp[i];
    }
    return max;
}


//
//  main.cpp
//  LC58
//
//  Created by H.HUA WU on 11/29/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int lengthOfLastWord(string s) {
    int result = 0;
    int tail = int (s.length()-1);
    while(tail >= 0 && s[tail] == ' ')
    {
        tail--;
    }
    while(tail>=0 && s[tail] != ' ')
    {
        result++;
        tail--;
    }
    return result;
}


//
//  main.cpp
//  LC66
//
//  Created by H.HUA WU on 11/29/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//


vector<int> plusOne(vector<int>& digits) {
    int len = int(digits.size());
    for(int i=len-1;i>=0;i--)
    {
        if(digits[i] == 9)
        {
            digits[i] = 0;
        }
        else
        {
            digits[i] += 1;
            return digits;
        }
    }
    digits[0] = 1;
    digits.push_back(0);
    return digits;
}


//
//  main.cpp
//  LC67
//
//  Created by H.HUA WU on 11/29/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

using namespace std;

string addBinary(string a, string b) {
    string s = "";
    int asize = int (a.size()-1);
    int bsize = int (b.size()-1);
    int gap = 0;
    while(asize >= 0 || bsize >= 0)
    {
        string aa = asize >=0 ? a.substr(asize,1) : "0";
        string bb = bsize >=0 ? b.substr(bsize,1) : "0";
        int ai = atoi(aa.c_str());
        int bi = atoi(bb.c_str());
        if(ai+bi+gap >= 2)
        {
            string temp = to_string((ai+bi+gap)%2);
            s = temp+s;
            gap = 1;
        }
        else
        {
            s = to_string(ai+bi+gap) + s;
            gap = 0;
        }
        asize--;
        bsize--;
        
    }
    if(gap == 1)
    {
        s = "1" + s;
    }
    return s;
}


//
//  main.cpp
//  LC69
//
//  Created by H.HUA WU on 11/30/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int mySqrt(int x) {
    int left = 1;
    int right = x;
    while(left<=right)
    {
        int mid = left + (right-left)/2;
        if(mid == x/mid)
        {
            return mid;
        }
        else if(mid>x/mid)
        {
            right = mid-1;
        }
        else
        {
            left = mid+1;
        }
    }
    return right;
}

//
//  main.cpp
//  LC70
//
//  Created by H.HUA WU on 11/30/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int climbStairs(int n) {
    if(n<=2)
    {
        return n;
    }
    int *T = new int[n+1];
    T[0] = 0;
    T[1] = 1;
    T[2] = 2;
    for(int i=3;i<=n;i++)
    {
        T[i] = T[i-1]+T[i-2];
    }
    int result = T[n];
    delete []T;
    return result;
}

//
//  main.cpp
//  LC83
//
//  Created by H.HUA WU on 12/1/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

ListNode* deleteDuplicates(ListNode* head) {
    if(head == NULL)
    {
        return head;
    }
    ListNode* p = head;
    ListNode* q = p->next;
    while(q)
    {
        if(q->val == p->val)
        {
            q = q->next;
        }
        else
        {
            p->next = q;
            p = q;
            q = q->next;
        }
    }
    p->next = q;
    return head;
}

//
//  main.cpp
//  LC88
//
//  Created by H.HUA WU on 12/1/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int index = m+n-1;
    int i = m-1;
    int j = n-1;
    while(i>=0&&j>=0)
    {
        nums1[index--] = nums1[i]>nums2[j]? nums1[i--]:nums2[j--];
    }
    if(j>=0)
    {
        for(int x=0;x<=j;x++)
        {
            nums1[x] = nums2[x];
        }
    }
}


//
//  main.cpp
//  LC100
//
//  Created by H.HUA WU on 12/3/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

bool isSameTree(TreeNode* p, TreeNode* q) {
    if(p==NULL || q == NULL)
    {
        return p == q;
    }
    
    if(p->val != q->val)
    {
        return false;
    }
    else
    {
        return isSameTree(p->left, q->left)&&isSameTree(p->right, q->right);
    }
}

//
//  main.cpp
//  LC101
//
//  Created by H.HUA WU on 12/3/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

bool comparenode(TreeNode* p, TreeNode* q)
{
    if(p == NULL && q == NULL)
    {
        return true;
    }
    if(p == NULL || q == NULL)
    {
        return false;
    }
    if(p->val != q->val)
    {
        return false;
    }
    
    return comparenode(p->left, q->right) && comparenode(p->right, q->left);
}

bool isSymmetric(TreeNode* root) {
    if(root == NULL)
    {
        return true;
    }
    return comparenode(root->left, root->right);
}


//
//  main.cpp
//  LC104
//
//  Created by H.HUA WU on 12/3/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int maxDepth(TreeNode* root) {
    return root == NULL? 0 : max(maxDepth(root->left),maxDepth(root->right))+1;
}


//
//  main.cpp
//  LC107
//
//  Created by H.HUA WU on 12/4/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

vector<vector<int>> result;

void DFS(TreeNode* root, int level)
{
    if(root != NULL)
    {
        if(level == result.size())
        {
            result.push_back(vector<int>());
        }
        result[level].push_back(root->val);
        if(root->left)
        {
            DFS(root->left, level+1);
        }
        if(root->right)
        {
            DFS(root->right, level+1);
        }
    }
}

vector<vector<int>> levelOrderBottom(TreeNode* root) {
    DFS(root, 0);
    reverse(result.begin(), result.end());
    return result;
}

//
//  main.cpp
//  LC108
//
//  Created by H.HUA WU on 12/4/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

TreeNode* sortedArrayToBST(vector<int>& nums) {
    if(nums.size()==0)
    {
       return NULL;
    }
    if(nums.size()==1)
    {
        TreeNode* p = new TreeNode(nums[0]);
        return p;
    }

    int mid = nums[nums.size()/2];
    TreeNode* root = new TreeNode(mid);
    vector<int> leftnums(nums.begin(),nums.begin()+nums.size()/2);
    vector<int> rightnums(nums.begin()+nums.size()/2+1,nums.end());
    root->left = sortedArrayToBST(leftnums);
    root->right = sortedArrayToBST(rightnums);
    return root;
}


//
//  main.cpp
//  LC110
//
//  Created by H.HUA WU on 12/4/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int depth(TreeNode* root)
{
    if(root==NULL)
    {
        return 0;
    }
    return max(depth(root->left),depth(root->right))+1;
}

bool isBalanced(TreeNode* root) {
    if(root == NULL)
    {
        return true;
    }
    return abs(depth(root->left)-depth(root->right))<=1 && isBalanced(root->left) && isBalanced(root->right);
}


//
//  main.cpp
//  LC111
//
//  Created by H.HUA WU on 12/5/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//


int minDepth(TreeNode* root) {
    if(root == NULL)
    {
        return 0;
    }
    if(root->left == NULL)
    {
        return minDepth(root->right) + 1;
    }
    if(root->right == NULL)
    {
        return minDepth(root->left) + 1;
    }
    return min(minDepth(root->left),minDepth(root->right)) + 1;
}



//
//  main.cpp
//  LC112
//
//  Created by H.HUA WU on 12/5/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

bool hasPathSum(TreeNode* root, int sum) {
    if(root == NULL)
    {
       return false;
    }
    if(root->val == sum && root->left == NULL && root->right == NULL)
    {
        return true;
    }
    return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);
}


//
//  main.cpp
//  LC118
//
//  Created by H.HUA WU on 12/5/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

vector<vector<int>> generate(int numRows) {
    vector<vector<int>> res;
    for(int i=0;i<numRows;i++)
    {
        res.resize(i+1);
        res[i][0] = res[i][i] = 1;
        for(int j = 1;j<i;j++)
        {
            res[i][j] = res[i-1][j-1]+res[i-1][j];
        }
    }
    return res;
}


//
//  main.cpp
//  LC119
//
//  Created by H.HUA WU on 12/5/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

vector<int> getRow(int rowIndex) {
    vector<int> res(rowIndex+1,0);
    res[0] = 1;
    for(int i=1;i<rowIndex+1;i++)
    {
        for(int j=i;j>=1;j--)
        {
            res[j] += res[j-1];
        }
    }
    return res;
}


//
//  main.cpp
//  LC121
//
//  Created by H.HUA WU on 12/6/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int maxProfit(vector<int>& prices) {
    int size = int(prices.size());
    int maxprofit = 0;
    int minprice = INT_MAX;
    for(int i=0;i<size;i++)
    {
        minprice = minprice>prices[i]? prices[i]:minprice;
        maxprofit = maxprofit < prices[i]-minprice? prices[i]-minprice:maxprofit;
    }
    
    return maxprofit;
}


//
//  main.cpp
//  LC122
//
//  Created by H.HUA WU on 12/6/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int maxProfit(vector<int>& prices) {
    int profit = 0;
    for(int i=1;i<prices.size();i++)
    {
        profit += max(prices[i]-prices[i-1], 0);
    }
    return profit;
}


//
//  main.cpp
//  LC136
//
//  Created by H.HUA WU on 12/6/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int singleNumber(vector<int>& nums) {
    int result = 0;
    for(int i=0;i<nums.size();i++)
    {
        result ^=nums[i];
    }
    return result;
}


//
//  main.cpp
//  LC141
//
//  Created by H.HUA WU on 12/7/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

bool hasCycle(ListNode *head) {
    if(head == NULL || head -> next == NULL)
    {
        return false;
    }
    ListNode* slow = head;
    ListNode* fast = head;
    while(slow->next!=NULL && fast->next!= NULL && fast->next->next != NULL)
    {
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast)
        {
            return true;
        }
    }
    return false;
}


//
//  main.cpp
//  LC160
//
//  Created by H.HUA WU on 12/7/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if(headA == NULL || headB == NULL)
    {
        return NULL;
    }
    
    ListNode *p1 = headA;
    ListNode *p2 = headB;
    
    while(p1 != NULL && p2 != NULL && p1!=p2)
    {
        p1 = p1->next;
        p2 = p2->next;
        if(p1 == p2)
        {
            return p1;
        }
        
        if(p1 == NULL)
        {
            p1 = headB;
        }
        if(p2 == NULL)
        {
            p2 = headA;
        }
    }
    return p1;
}


//
//  main.cpp
//  LC167
//
//  Created by H.HUA WU on 12/8/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

vector<int> twoSum(vector<int>& numbers, int target) {
    
    int l = 0;
    int r = int(numbers.size())-1;
    vector<int> res;
    while(l<r)
    {
        if(numbers[l] + numbers[r] == target)
        {
            res.push_back(l+1);
            res.push_back(r+1);
            return res;
        }
        else if(numbers[l] + numbers[r]>target)
        {
            r--;
        }
        else
        {
            l++;
        }
    }
    return res;
}


//
//  main.cpp
//  LC168
//
//  Created by H.HUA WU on 12/9/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

string convertToTitle(int n) {
    return n == 0? "":convertToTitle((n-1)/26) + char((n-1)%26 + 'A');
}


//
//  main.cpp
//  LC169
//
//  Created by H.HUA WU on 12/31/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//


int majorityElement(vector<int>& nums) {
    unordered_map<int,int> counts;
    int size = int(nums.size());
    for(int i=0;i<size;i++)
    {
        if(++counts[nums[i]]>size/2)
        {
            return nums[i];
        }
    }
    return -1;
}


//
//  main.cpp
//  LC171
//
//  Created by H.HUA WU on 12/31/17.
//  Copyright © 2017 H.HUA WU. All rights reserved.
//

int titleToNumber(string s) {
    int sizew = int(s.length());
    if(sizew == 0)
    {
        return 0;
    }
    int result = 0;
    for(int i=0;i<sizew;i++)
    {
        result = result*26 + (s.at(i) - 'A' + 1);
    }
    return result;
}


//
//  main.cpp
//  LC172
//
//  Created by H.HUA WU on 1/1/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

int trailingZeroes(int n) {
    int result = 0;
    while(n>0)
    {
        result += n/5;
        n = n/5;
    }
    return result;
}


//
//  main.cpp
//  LC189
//
//  Created by H.HUA WU on 1/1/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

void rotate(vector<int>& nums, int k) {

    int n = int(nums.size());
    if(n <= 1 || k<0)
        return;
    
    vector<int> numscopy(n);
    for(int i =0 ; i<n ; i++)
    {
        numscopy[i] = nums[i];
    }
    
    for(int i=0; i<n; i++)
    {
        nums[(i+k)%n] = numscopy[i];
    }
}


//
//  main.cpp
//  LC198
//
//  Created by H.HUA WU on 1/4/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

int rob(vector<int>& nums) {
    int size = int(nums.size());
    if(size == 0)
    {
        return 0;
    
    }
    if(size == 1)
    {
        return nums[0];
    }
    if(size == 2)
    {
        return max(nums[0],nums[1]);
    }
    vector<int> f(size,0);
    f[0] = nums[0];
    f[1] = max(nums[0],nums[1]);
    for(int i =2;i<size;i++)
    {
        f[i] = max(f[i-1],f[i-2]+nums[i]);
    }
    return f[size-1];
}


//
//  main.cpp
//  LC203
//
//  Created by H.HUA WU on 1/4/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

ListNode* removeElements(ListNode* head, int val) {
    ListNode* temp = new ListNode(-1);
    temp->next = head;
    ListNode* res = temp;
    while(temp != NULL && temp->next != NULL)
    {
        if(temp->next->val == val)
        {
            ListNode* p = temp->next;
            temp->next = temp->next->next;
            delete p;
        }
        else
        {
            temp = temp->next;
        }
    }
    
    return res->next;
}


//
//  main.cpp
//  LC205
//
//  Created by H.HUA WU on 1/5/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

bool isIsomorphic(string s, string t) {
    vector<char> smapt(128,0);
    vector<char> tmaps(128,0);
    
    int nlen = int(s.length());
    for(int i=0;i<nlen;i++)
    {
        if(smapt[s[i]] == 0 && tmaps[t[i]] == 0)
        {
            smapt[s[i]] = t[i];
            tmaps[t[i]] = s[i];
        }
        else if(smapt[s[i]] != t[i] || tmaps[t[i]] != s[i])
        {
            return false;
        }
    }
    return true;
}


//
//  main.cpp
//  LC242
//
//  Created by H.HUA WU on 1/11/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

bool isAnagram(string s, string t) {
    sort(s.begin(), s.end());
    sort(t.begin(), t.end());
    return s==t;
}


//
//  main.cpp
//  LC257
//
//  Created by H.HUA WU on 1/12/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

void createpath(vector<string>& res, TreeNode* root, string strp)
{
    if(root->left == NULL && root->right == NULL)
    {
        res.push_back(strp);
        return;
    }
    
    if(root->left)
    {
        createpath(res, root->left, strp+"->"+to_string(root->left->val));
    }
    if(root->right)
    {
        createpath(res, root->right, strp+"->"+to_string(root->right->val));
    }
}


vector<string> binaryTreePaths(TreeNode* root) {
    vector<string> res;
    if(root==NULL)
    {
        return res;
    }
    createpath(res,root,to_string(root->val));
    return res;
}


//
//  main.cpp
//  LC258
//
//  Created by H.HUA WU on 1/12/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

int addDigits(int num) {
    while(num>=10)
    {
        num = num/10 + num%10;
    }
    return num;
}


//
//  main.cpp
//  LC263
//
//  Created by H.HUA WU on 1/13/18.
//  Copyright © 2018 H.HUA WU. All rights reserved.
//

bool isUgly(int num) {
    if(num == 0)
    {
        return false;
    }
    while(num%2 == 0)
    {
        num = num/2;
    }
    while(num%3 == 0)
    {
        num = num/3;
    }
    while(num%5 == 0)
    {
        num = num/5;
    }
    
    if(num == 1)
    {
        return true;
    }
    else
    {
        return false;
    }
}
